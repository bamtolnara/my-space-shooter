<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>ÌîΩÏÖÄ ÏäàÌÑ∞: Î™ÖÏòàÏùò Ï†ÑÎãπ</title>
    
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">

    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>

    <style>
        body { margin: 0; background: #222; display: flex; justify-content: center; align-items: center; height: 100vh; overflow: hidden; font-family: 'Courier New', monospace; color: white; touch-action: none; user-select: none; -webkit-user-select: none; }
        #game-container { position: relative; width: 100%; height: 100%; max-width: 500px; max-height: 800px; background: #000; box-shadow: 0 0 30px rgba(0,0,0,0.5); overflow: hidden; }
        canvas { display: block; width: 100%; height: 100%; image-rendering: pixelated; }
        .ui-layer { position: absolute; pointer-events: none; width: 100%; height: 100%; top: 0; left: 0; z-index: 10; }
        #score-ui { position: absolute; top: 15px; left: 15px; font-size: 24px; font-weight: bold; text-shadow: 2px 2px 0 #000; }
        #stage-ui { position: absolute; top: 15px; right: 15px; font-size: 24px; font-weight: bold; color: #00e5ff; text-shadow: 2px 2px 0 #000; }
        #msg-ui { position: absolute; top: 40%; width: 100%; text-align: center; font-size: 50px; font-weight: bold; display: none; text-shadow: 0 0 20px red; color: red; animation: blink 0.5s infinite; }
        .screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.95); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 100; }
        
        h1 { 
            font-family: 'Press Start 2P', cursive;
            font-size: 38px; margin-bottom: 20px; 
            text-align: left; width: 100%; padding-left: 30px; box-sizing: border-box;
            color: #fff; text-shadow: 3px 3px 0px #00e5ff, 0 0 15px #00e5ff, 0 0 30px #00e5ff;
            line-height: 1.5; white-space: normal;
        }

        /* ‚òÖ‚òÖ‚òÖ Îû≠ÌÇπ Î∞ïÏä§ ÎîîÏûêÏù∏ ÏàòÏ†ï (3Ïù∏ Ï†ÑÏö©) ‚òÖ‚òÖ‚òÖ */
        .ranking-box { 
            width: 80%; 
            background: rgba(17, 17, 17, 0.9); 
            border: 2px solid #ffd700; /* ÌÖåÎëêÎ¶¨Î•º Í∏àÏÉâÏúºÎ°ú */
            padding: 15px; 
            margin-bottom: 20px; 
            border-radius: 10px; 
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.2);
        }
        .rank-list { 
            /* Ïä§ÌÅ¨Î°§ Ï†úÍ±∞ÌïòÍ≥† ÎÇ¥Ïö©Î¨ºÏóê ÎßûÍ≤å */
            overflow-y: visible; 
            font-size: 14px; 
            text-align: left; 
        }
        .rank-item { 
            display: flex; 
            justify-content: space-between; 
            border-bottom: 1px dashed #333; 
            padding: 12px 0; /* Í∞ÑÍ≤© ÎÑìÌûò */
            font-weight: bold;
        }
        .rank-item:last-child { border-bottom: none; }

        button { padding: 15px 40px; font-size: 20px; margin-top: 10px; cursor: pointer; background: #00e5ff; border: none; font-family: inherit; font-weight: bold; border-radius: 10px; box-shadow: 0 0 10px #00e5ff; }
        button:active { transform: scale(0.95); background: white; }
        input { padding: 12px; font-size: 18px; text-align: center; background: #222; border: 2px solid #555; color: white; margin-bottom: 10px; border-radius: 5px; width: 200px; }
        
        #select-container { display: flex; gap: 8px; margin-bottom: 15px; flex-wrap: wrap; justify-content: center; }
        .plane-btn { 
            width: 45px; height: 45px; 
            border: 2px solid #444; opacity: 0.5; cursor: pointer; 
            display: flex; justify-content: center; align-items: center;
            background: #222; border-radius: 5px; position: relative;
        }
        .plane-btn.selected { border-color: #fff; opacity: 1.0; transform: scale(1.1); box-shadow: 0 0 10px #fff; background: #444; }
        .locked { opacity: 0.2; cursor: not-allowed; }
        
        @keyframes blink { 0% { opacity: 1; } 50% { opacity: 0; } 100% { opacity: 1; } }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        <div class="ui-layer">
            <div id="score-ui">SCORE: 0</div>
            <div id="stage-ui">STAGE 1</div>
            <div id="msg-ui">WARNING</div>
        </div>
        <div id="start-screen" class="screen">
            <h1>PIXEL<br>SHOOTER</h1>
            
            <div class="ranking-box">
                <div style="text-align:center; color:#ffd700; margin-bottom:10px; font-size: 16px; text-shadow: 0 0 5px gold;">üèÜ HALL OF FAME</div>
                <div id="start-ranking" class="rank-list">Î°úÎî©Ï§ë...</div>
            </div>
            
            <div id="select-container"></div>
            <input type="text" id="username" placeholder="ÎãâÎÑ§ÏûÑ" maxlength="6">
            <button id="startBtn">GAME START</button>
            <button id="donateBtn" style="background:#ff4081; font-size:14px; padding:10px; margin-top:10px;">‚òï Í∞úÎ∞úÏûê ÌõÑÏõê (Î≥¥ÎÑàÏä§)</button>
        </div>
        <div id="game-over-screen" class="screen" style="display:none;">
            <h1 style="color:red; text-shadow: 3px 3px 0px #b71c1c; font-size: 35px; line-height: 1.5; text-align: center; padding-left: 0;">GAME<br>OVER</h1>
            <div id="final-score" style="font-size:28px; margin-bottom:10px;">SCORE: 0</div>
            <div class="ranking-box">
                <div style="text-align:center; color:#ffd700; margin-bottom:10px;">üèÜ TOP 3</div>
                <div id="gameover-ranking" class="rank-list"></div>
            </div>
            <div id="unlock-msg" style="color:yellow; margin-bottom:10px; font-size:16px;"></div>
            <button onclick="location.reload()">RESTART</button>
        </div>
    </div>

    <script>
        const PIXEL = 4;
        const FPS = 60;
        const FPS_INTERVAL = 1000/FPS;
        const GAME_WIDTH = 400;
        const GAME_HEIGHT = 600;
        const DRONE_OFFSET_X = 50; 
        const DRONE_OFFSET_Y = 10;

        const firebaseConfig = { apiKey: "AIzaSyDZrdz1YPykH3cMfYrt1Z18fmqFP66ZPNE", authDomain: "pixel-shooter-1e9b9.firebaseapp.com", databaseURL: "https://pixel-shooter-1e9b9-default-rtdb.firebaseio.com", projectId: "pixel-shooter-1e9b9", storageBucket: "pixel-shooter-1e9b9.firebasestorage.app", messagingSenderId: "1043130908247", appId: "1:1043130908247:web:0688292b8d8bbacd656d12" };
        let db, isDbConnected = false;
        function initFirebase() { try { if (typeof firebase !== 'undefined' && !firebase.apps.length) { firebase.initializeApp(firebaseConfig); db = firebase.database(); isDbConnected = true; loadRanking(); } } catch (e) { document.getElementById('start-ranking').innerHTML = "Ïò§ÌîÑÎùºÏù∏ Î™®Îìú"; } }
        function saveScore(name, score) { if (!isDbConnected) return; try { db.ref('scores').push({ username: name || "Player", score: score, date: Date.now() }); } catch(e) {} }
        
        // ‚òÖ‚òÖ‚òÖ Îû≠ÌÇπ Î°úÎìú Ìï®Ïàò ÏàòÏ†ï (Top 3 + Î©îÎã¨) ‚òÖ‚òÖ‚òÖ
        function loadRanking() { 
            if (!isDbConnected) return; 
            try { 
                // limitToLast(3)ÏúºÎ°ú Î≥ÄÍ≤Ω
                db.ref('scores').orderByChild('score').limitToLast(3).once('value', (snapshot) => { 
                    const data = snapshot.val(); 
                    let list = []; 
                    if (data) { 
                        for (let key in data) list.push(data[key]); 
                        list.sort((a, b) => b.score - a.score); // Ï†êÏàò ÎÇ¥Î¶ºÏ∞®Ïàú Ï†ïÎ†¨
                    } 
                    
                    const medals = ['ü•á', 'ü•à', 'ü•â'];
                    const colors = ['#ffd700', '#c0c0c0', '#cd7f32']; // Í∏à, ÏùÄ, Îèô ÏÉâÏÉÅ ÏΩîÎìú

                    const html = list.map((item, i) => {
                        const medal = medals[i] || (i + 1) + '.';
                        const color = colors[i] || 'white';
                        // 1Îì±ÏùÄ Í∏ÄÏî®Î•º Ï°∞Í∏à Îçî ÌÅ¨Í≤å
                        const fontSize = i === 0 ? '16px' : '14px';
                        
                        return `
                            <div class="rank-item" style="color:${color}; font-size:${fontSize}">
                                <span>${medal} ${item.username}</span>
                                <span>${item.score.toLocaleString()}</span>
                            </div>
                        `;
                    }).join('');
                    
                    document.getElementById('start-ranking').innerHTML = html || "Í∏∞Î°ù ÏóÜÏùå"; 
                    document.getElementById('gameover-ranking').innerHTML = html || "Í∏∞Î°ù ÏóÜÏùå"; 
                }); 
            } catch(e){} 
        }

        const SPRITES = {
            planes: [
                [[0,0,0,0,2,0,0,0,0],[0,0,0,1,2,1,0,0,0],[0,0,1,1,2,1,1,0,0],[0,1,1,1,1,1,1,1,0],[1,1,1,3,1,3,1,1,1],[1,3,1,3,1,3,1,3,1],[1,3,0,3,1,3,0,3,1],[0,0,0,1,3,1,0,0,0]],
                [[0,0,0,0,2,0,0,0,0],[0,0,0,1,2,1,0,0,0],[0,0,1,1,2,1,1,0,0],[0,1,1,1,1,1,1,1,0],[1,1,3,1,1,1,3,1,1],[1,3,3,1,3,1,3,3,1],[0,3,3,0,3,0,3,3,0],[0,2,2,0,0,0,2,2,0]],
                [[0,1,1,1,2,1,1,1,0],[1,1,1,1,2,1,1,1,1],[1,2,1,1,3,1,1,2,1],[1,1,1,3,3,3,1,1,1],[1,1,1,1,3,1,1,1,1],[0,1,1,0,3,0,1,1,0],[0,3,3,0,3,0,3,3,0]],
                [[0,0,0,2,2,2,0,0,0],[0,0,1,1,2,1,1,0,0],[0,1,1,3,1,3,1,1,0],[1,1,1,1,3,1,1,1,1],[1,3,1,1,3,1,1,3,1],[0,1,1,3,1,3,1,1,0],[0,0,3,3,0,3,3,0,0],[0,2,0,2,0,2,0,2,0]],
                [[0,2,0,0,1,0,0,2,0],[2,1,2,0,1,0,2,1,2],[0,2,0,1,2,1,0,2,0],[0,0,1,1,2,1,1,0,0],[0,1,1,3,1,3,1,1,0],[1,1,3,1,3,1,3,1,1],[1,3,1,0,3,0,1,3,1],[0,2,0,0,2,0,0,2,0]]
            ],
            enemy: [[1,0,0,0,0,0,1],[0,1,1,1,1,1,0],[1,1,0,3,0,1,1],[1,3,1,3,1,3,1],[0,3,0,3,0,3,0],[0,3,0,0,0,3,0]],
            boss: [[0,0,1,1,1,0,0],[0,1,1,2,1,1,0],[1,1,3,1,3,1,1],[1,3,3,1,3,3,1],[0,3,0,3,0,3,0],[1,3,0,0,0,3,1]],
            drone: [[0,2,0],[1,1,1],[1,3,1],[0,3,0]],
            item_P: [[1,0,1,0,1,1,1],[1,0,1,0,1,0,1],[1,0,1,0,1,1,1],[1,0,1,0,1,0,0],[1,1,1,0,1,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,0,0]], 
            item_S: [[0,0,0,0,0,0,0],[1,1,0,0,0,1,1],[1,1,1,0,1,1,1],[0,1,1,1,1,1,0],[0,0,1,1,1,0,0],[0,0,0,1,0,0,0],[0,0,0,0,0,0,0]],
            item_H: [[1,1,1,1,1,1,1],[1,0,0,0,0,0,1],[1,0,1,1,1,0,1],[1,0,1,1,1,0,1],[0,1,0,1,0,1,0],[0,0,1,0,1,0,0],[0,0,0,1,0,0,0]],
            item_B: [[0,0,0,1,0,0,0],[0,0,1,1,1,0,0],[0,0,1,2,1,0,0],[0,0,1,2,1,0,0],[0,0,1,2,1,0,0],[0,1,1,3,1,1,0],[0,1,0,3,0,1,0]],
            item_O: [[0,0,1,1,1,0,0],[0,1,1,2,1,1,0],[1,1,0,3,0,1,1],[1,2,3,2,3,2,1],[1,1,0,3,0,1,1],[0,1,1,2,1,1,0],[0,0,1,1,1,0,0]]
        };

        const PLANES = [
            { name: "BASIC", color: "#e0e0e0", sub: "#00ffff", shade: "#9e9e9e", speed: 5, req: 0 },
            { name: "SPEED", color: "#448aff", sub: "#ffff00", shade: "#1565c0", speed: 8, req: 50000 },
            { name: "TANK",  color: "#ff5252", sub: "#ffc107", shade: "#c62828", speed: 4, req: 100000 },
            { name: "VIPER", color: "#69f0ae", sub: "#e040fb", shade: "#00c853", speed: 6, req: 200000 },
            { name: "VOID",  color: "#b388ff", sub: "#ffffff", shade: "#6200ea", speed: 7, req: 400000 }
        ];

        const STAGE_COLORS = [
            { main: '#ff5252', shade: '#c62828' }, { main: '#00e5ff', shade: '#00b0ff' }, { main: '#ffff00', shade: '#fbc02d' },
            { main: '#ff1744', shade: '#b71c1c' }, { main: '#ff9100', shade: '#e65100' }, { main: '#76ff03', shade: '#33691e' }
        ];

        function initAtlas() {
            PLANES.forEach((p, i) => bufferSprite(`plane_${i}`, SPRITES.planes[i], p.color, p.sub, p.shade));
            bufferSprite('drone', SPRITES.drone, '#00ffff', 'white', '#00aaaa');
            STAGE_COLORS.forEach((c, i) => {
                bufferSprite(`enemy_s${i+1}`, SPRITES.enemy, c.main, 'white', c.shade);
                bufferSprite(`boss_s${i+1}`, SPRITES.boss, c.main, 'white', c.shade, 3);
            });
            bufferSprite('enemy_hit', SPRITES.enemy, 'white', 'white', 'white');
            bufferSprite('boss_hit', SPRITES.boss, 'white', 'white', 'white', 3);
            bufferSprite('item_P', SPRITES.item_P, '#ffd700', '#ffffff', '#daa520'); 
            bufferSprite('item_S', SPRITES.item_S, '#ffffff', '#e0e0e0', '#cccccc');
            bufferSprite('item_H', SPRITES.item_H, '#2979ff', '#ffffff', '#0d47a1');
            bufferSprite('item_B', SPRITES.item_B, '#d50000', '#ff8a80', '#ff1744');
            bufferSprite('item_O', SPRITES.item_O, '#b388ff', '#ffffff', '#6200ea');
        }

        const ATLAS = document.createElement('canvas'); const ATLAS_CTX = ATLAS.getContext('2d'); const SPRITE_MAP = {}; let atlasX = 0;
        ATLAS.width = 2000; ATLAS.height = 200;
        function bufferSprite(n, m, c1, c2, c3, s=1) {
            const w = m[0].length*PIXEL*s, h = m.length*PIXEL*s;
            for(let r=0;r<m.length;r++) for(let c=0;c<m[r].length;c++) { const v=m[r][c]; if(v) { ATLAS_CTX.fillStyle=v===1?(c1||'white'):v===2?(c2||'white'):(c3||'gray'); ATLAS_CTX.fillRect(atlasX+c*PIXEL*s, r*PIXEL*s, PIXEL*s, PIXEL*s); } }
            SPRITE_MAP[n] = {x:atlasX, y:0, w:w, h:h}; atlasX+=w+10;
        }
        initAtlas();

        const canvas = document.getElementById('gameCanvas'); const ctx = canvas.getContext('2d');
        canvas.width = GAME_WIDTH; canvas.height = GAME_HEIGHT;

        let isRunning = false, score = 0, stage = 1;
        let player = { x: 180, y: 500, w: 0, h: 0, speed: 5, power: 1, shield: false, invincible: 0, drones: [] };
        let bullets=[], bossBullets=[], enemies=[], items=[], boss=null, particles=[], stars=[], keys={};
        let lastTime=0, lastShotTime=0;
        let touchX=null, selectedIdx=0, unlocked=[0], currentUsername="Player";

        for(let i=0; i<60; i++) {
            const speed = Math.random() < 0.2 ? Math.random()*20 + 10 : Math.random()*2 + 0.5;
            stars.push({
                x: Math.random() * GAME_WIDTH,
                y: Math.random() * GAME_HEIGHT,
                w: speed > 5 ? 1 : 2,
                h: speed > 5 ? Math.random()*30 + 10 : 2,
                speed: speed,
                color: speed > 5 ? `rgba(255,255,255,${Math.random()*0.3})` : `rgba(255,255,255,${Math.random()*0.8})`
            });
        }

        function getPos(e) { const r=canvas.getBoundingClientRect(); return (e.touches?e.touches[0].clientX:e.clientX - r.left)*(canvas.width/r.width); }
        canvas.addEventListener('touchstart', e=>{e.preventDefault(); touchX=getPos(e);}, {passive:false});
        canvas.addEventListener('touchmove', e=>{e.preventDefault(); if(!isRunning||touchX===null)return; const cx=getPos(e); player.x=Math.max(0,Math.min(GAME_WIDTH-player.w, player.x+(cx-touchX))); touchX=cx;}, {passive:false});
        canvas.addEventListener('touchend', ()=>touchX=null);
        window.addEventListener('keydown', e=>keys[e.code]=true);
        window.addEventListener('keyup', e=>keys[e.code]=false);

        function renderSelectButtons() {
            const c = document.getElementById('select-container'); c.innerHTML = "";
            PLANES.forEach((p, i) => {
                const btn = document.createElement('div'); btn.className = 'plane-btn' + (i===selectedIdx ? ' selected' : '') + (unlocked.includes(i) ? '' : ' locked');
                btn.style.borderColor = p.color;
                const cvs = document.createElement('canvas'); cvs.width = 40; cvs.height = 40;
                const ctx = cvs.getContext('2d');
                const matrix = SPRITES.planes[i]; const pixelSize = 4;
                const w = matrix[0].length * pixelSize; const h = matrix.length * pixelSize;
                const offX = (40 - w) / 2; const offY = (40 - h) / 2;
                for(let r=0; r<matrix.length; r++) for(let c=0; c<matrix[r].length; c++) { const v = matrix[r][c]; if(v) { ctx.fillStyle = v===1 ? p.color : v===2 ? p.sub : p.shade; ctx.fillRect(offX + c*pixelSize, offY + r*pixelSize, pixelSize, pixelSize); } }
                btn.appendChild(cvs);
                if(!unlocked.includes(i)) { btn.innerHTML = "<span style='font-size:20px'>üîí</span>"; }
                btn.onclick = () => { if(!unlocked.includes(i)) { alert(`Ìï¥Í∏à: ${p.req.toLocaleString()}Ï†ê`); return; } selectedIdx = i; renderSelectButtons(); };
                c.appendChild(btn);
            });
        }

        window.onload = () => {
            initFirebase(); try { const s = JSON.parse(localStorage.getItem('pixelShooterUnlocks')); if(s) unlocked = s; } catch(e){} renderSelectButtons();
            document.getElementById('startBtn').onclick = () => { currentUsername = document.getElementById('username').value.trim() || "Player"; document.getElementById('start-screen').style.display = 'none'; try { initAudio(); } catch(e){} startGame(); };
            document.getElementById('donateBtn').onclick = () => { player.shield = true; alert("ÌõÑÏõê Í∞êÏÇ¨! Ïâ¥Îìú Ïû•Ï∞©!"); };
            document.body.addEventListener('click', () => { try{initAudio(); if(!bgmPlaying) playBgm('intro');}catch(e){} }, {once:true});
        };

        function startGame() {
            isRunning = true; score = 0; stage = 1;
            const pData = PLANES[selectedIdx];
            const sMap = SPRITE_MAP[`plane_${selectedIdx}`];
            player = { ...player, x: 180, y: 450, w: sMap.w, h: sMap.h, speed: pData.speed, color: pData.color, sub: pData.sub, shade: pData.shade, power: 1, invincible: 0, drones: [] };
            bullets=[]; bossBullets=[]; enemies=[]; items=[]; boss=null; particles=[];
            document.getElementById('score-ui').innerText = "SCORE: 0"; document.getElementById('stage-ui').innerText = "STAGE 1"; document.getElementById('msg-ui').style.display = 'none';
            try { playBgm('game'); } catch(e) {}
            if(window.gameLoopId) cancelAnimationFrame(window.gameLoopId); loop();
        }

        function loop(timestamp) {
            if(!isRunning) return;
            try { const dt = timestamp - lastTime; if(dt >= FPS_INTERVAL) { lastTime = timestamp - (dt % FPS_INTERVAL); update(); draw(); } } catch (e) { console.error(e); }
            window.gameLoopId = requestAnimationFrame(loop);
        }

        function update() {
            if(keys['ArrowLeft']) player.x -= player.speed; if(keys['ArrowRight']) player.x += player.speed;
            if(keys['ArrowUp']) player.y -= player.speed; if(keys['ArrowDown']) player.y += player.speed;
            player.x = Math.max(0, Math.min(GAME_WIDTH - player.w, player.x)); player.y = Math.max(0, Math.min(GAME_HEIGHT - player.h, player.y));

            stars.forEach(s => {
                s.y += s.speed;
                if(s.y > GAME_HEIGHT) { s.y = -s.h; s.x = Math.random() * GAME_WIDTH; }
            });

            const centerX = player.x + (player.w/2), droneW = SPRITE_MAP['drone'].w, spacing = 50;
            player.drones.forEach((d, i) => {
                const tx = centerX + (i === 0 ? -spacing : spacing) - (droneW / 2), ty = player.y + 10;
                d.x += (tx - d.x) * 0.2; d.y += (ty - d.y) * 0.2;
            });

            if(Date.now() - lastShotTime > 90) {
                const cx = player.x + (player.w/2) - 2;
                if(player.power === 1) spawnBullet(cx, player.y);
                else { spawnBullet(player.x + 5, player.y); spawnBullet(player.x + player.w - 9, player.y); }
                player.drones.forEach(d => spawnBullet(d.x + (droneW/2) - 2, d.y));
                playSound('shoot'); lastShotTime = Date.now();
            }

            if(!boss && Math.random() < 0.03 + (stage * 0.005)) {
                const sMap = SPRITE_MAP[`enemy_s${Math.min(stage,6)}`];
                enemies.push({ x: Math.random()*(GAME_WIDTH-sMap.w), y: -sMap.h, w: sMap.w, h: sMap.h, hp: 1+Math.floor(stage/2), hit: 0 });
            }

            const stageIdx = Math.min(stage, 6);
            const scoreReq = [0, 5000, 20000, 50000, 100000, 200000, 300000][stageIdx] || 9999999;
            if(!boss && score >= scoreReq) {
                const sMap = SPRITE_MAP[`boss_s${stageIdx}`];
                boss = { x: GAME_WIDTH/2 - sMap.w/2, y: -sMap.h, w: sMap.w, h: sMap.h, hp: stage*50, maxHp: stage*50, dir: 1, hit: 0, lastShot: 0 };
                document.getElementById('msg-ui').style.display = 'block'; setTimeout(() => document.getElementById('msg-ui').style.display = 'none', 3000);
            }

            for(let i=bullets.length-1; i>=0; i--) { let b = bullets[i]; b.y -= 15; if(b.y < -20) bullets.splice(i, 1); }

            if(boss) {
                if(boss.y < 50) boss.y++;
                boss.x += boss.dir * (2 + stage*0.2);
                if(boss.x < 0 || boss.x > GAME_WIDTH - boss.w) boss.dir *= -1;

                let fireRate = 1000; 
                if (stage >= 2) fireRate = 800;
                if (stage >= 4) fireRate = 600;

                if(Date.now() - boss.lastShot > fireRate) {
                    const bx = boss.x + boss.w/2, by = boss.y + boss.h;
                    
                    if(stage === 1) {
                        bossBullets.push({x: bx, y: by, vx: 0, vy: 5});
                    }
                    else if(stage === 2) {
                        bossBullets.push({x: bx-10, y: by, vx: 0, vy: 6});
                        bossBullets.push({x: bx+10, y: by, vx: 0, vy: 6});
                    }
                    else if(stage === 3) {
                        const angle = Math.atan2(player.y - by, (player.x + player.w/2) - bx);
                        for(let a = -0.3; a <= 0.3; a += 0.3) {
                            bossBullets.push({x: bx, y: by, vx: Math.cos(angle+a)*6, vy: Math.sin(angle+a)*6});
                        }
                    }
                    else if(stage === 4) {
                        const angle = Math.atan2(player.y - by, (player.x + player.w/2) - bx);
                        bossBullets.push({x: bx, y: by, vx: Math.cos(angle)*12, vy: Math.sin(angle)*12, type: 'sniper'});
                    }
                    else if(stage === 5) {
                        for(let k=0; k<12; k++) {
                            const rad = (Math.PI*2 / 12) * k;
                            bossBullets.push({x: bx, y: by, vx: Math.cos(rad)*5, vy: Math.sin(rad)*5});
                        }
                    }
                    else {
                        for(let k=0; k<8; k++) {
                            const rad = (Math.PI*2 / 8) * k + (Date.now()/1000);
                            bossBullets.push({x: bx, y: by, vx: Math.cos(rad)*5, vy: Math.sin(rad)*5});
                        }
                        const angle = Math.atan2(player.y - by, (player.x + player.w/2) - bx);
                        bossBullets.push({x: bx, y: by, vx: Math.cos(angle)*12, vy: Math.sin(angle)*12, type: 'sniper'});
                    }
                    boss.lastShot = Date.now();
                }

                if(boss.hit > 0) boss.hit--;
                if(checkColl(player, boss)) hitPlayer();
                for(let j=bullets.length-1; j>=0; j--) {
                    if(checkColl(bullets[j], boss)) {
                        boss.hp--; boss.hit = 5; bullets.splice(j, 1);
                        if(boss.hp <= 0) { score += 5000*stage; stage++; document.getElementById('stage-ui').innerText = "STAGE " + stage; createParticle(boss.x, boss.y, 50); dropItem(boss.x+boss.w/2, boss.y+boss.h/2, 'O'); boss = null; bossBullets=[]; playSound('boss_die'); break; }
                    }
                }
            }

            for(let i=bossBullets.length-1; i>=0; i--) {
                let b = bossBullets[i]; b.x += b.vx; b.y += b.vy;
                if(b.y>GAME_HEIGHT || b.y<0 || b.x<0 || b.x>GAME_WIDTH) { bossBullets.splice(i, 1); continue; }
                const size = b.type === 'sniper' ? 10 : 8;
                if(checkColl(player, {x: b.x-size/2, y: b.y-size/2, w: size, h: size})) hitPlayer();
            }

            for(let i=enemies.length-1; i>=0; i--) {
                let e = enemies[i]; e.y += 3 + (stage * 0.5);
                if(e.hit > 0) e.hit--;
                if(e.y > GAME_HEIGHT) { enemies.splice(i, 1); continue; }
                if(checkColl(player, e)) hitPlayer();
                for(let j=bullets.length-1; j>=0; j--) {
                    if(checkColl(bullets[j], e)) {
                        e.hp--; e.hit = 5; bullets.splice(j, 1);
                        if(e.hp <= 0) { enemies.splice(i, 1); score += 100; createParticle(e.x, e.y); playSound('explosion'); if(Math.random() < 0.1) dropItem(e.x, e.y); break; }
                    }
                }
            }

            for(let i=items.length-1; i>=0; i--) { let it = items[i]; it.y += 3; if(it.y > GAME_HEIGHT) { items.splice(i, 1); continue; } if(checkColl(player, it)) { applyItem(it.type); items.splice(i, 1); playSound('powerup'); } }
            for(let i=particles.length-1; i>=0; i--) { let p = particles[i]; if(p.type === 'star') { p.y += p.speed; if(p.y > GAME_HEIGHT) p.y = 0; } else { p.life--; p.x += p.vx; p.y += p.vy; if(p.life <= 0) particles.splice(i, 1); } }
            document.getElementById('score-ui').innerText = "SCORE: " + score;
        }

        function draw() {
            ctx.fillStyle = 'black'; ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
            
            stars.forEach(s => {
                ctx.fillStyle = s.color;
                ctx.fillRect(s.x, s.y, s.w, s.h);
            });

            particles.forEach(p => { ctx.fillStyle = p.color; ctx.fillRect(p.x, p.y, p.size, p.size); });
            items.forEach(it => drawAtlas(`item_${it.type}`, it.x, it.y));

            if(player.invincible > 0) player.invincible--;
            if(player.invincible % 10 < 5) {
                drawAtlas(`plane_${selectedIdx}`, player.x, player.y);
                player.drones.forEach(d => drawAtlas('drone', d.x, d.y));
                if(player.shield) { ctx.strokeStyle = 'cyan'; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(player.x + (player.w/2), player.y + (player.h/2), 40, 0, Math.PI*2); ctx.stroke(); }
            }

            enemies.forEach(e => drawAtlas(e.hit > 0 ? 'enemy_hit' : `enemy_s${Math.min(stage,6)}`, e.x, e.y));

            if(boss) {
                drawAtlas(boss.hit > 0 ? 'boss_hit' : `boss_s${Math.min(stage,6)}`, boss.x, boss.y);
                ctx.fillStyle='red'; ctx.fillRect(boss.x, boss.y-10, boss.w, 8); ctx.fillStyle='lime'; ctx.fillRect(boss.x, boss.y-10, boss.w*(boss.hp/boss.maxHp), 8);
            }
            
            bossBullets.forEach(b => {
                ctx.fillStyle = b.type === 'sniper' ? '#ff00ff' : '#ff0000';
                const size = b.type === 'sniper' ? 10 : 8;
                ctx.fillRect(b.x-size/2, b.y-size/2, size, size);
            });

            ctx.fillStyle = '#ffff00'; bullets.forEach(b => ctx.fillRect(b.x, b.y, b.w, b.h));
        }

        function drawAtlas(n, x, y) { const s = SPRITE_MAP[n]; if(s) ctx.drawImage(ATLAS, s.x, s.y, s.w, s.h, x, y, s.w, s.h); }
        function spawnBullet(x, y) { bullets.push({x: x, y: y, w: 4, h: 20}); }
        function createParticle(x, y, count=10) { for(let i=0; i<count; i++) particles.push({ x:x+20, y:y+20, vx:(Math.random()-0.5)*10, vy:(Math.random()-0.5)*10, life:20, color:`hsl(${Math.random()*60},100%,50%)`, size:Math.random()*4+2 }); }
        function dropItem(x, y, t) { 
            const types = ['P','S','H','B','O']; 
            items.push({ x: x, y: y, w: 28, h: 28, type: t || types[Math.floor(Math.random()*types.length)] });
        }

        function applyItem(t) { if(t==='P') player.power=2; if(t==='S') player.speed+=2; if(t==='H') player.shield=true; if(t==='B') { enemies=[]; if(boss) boss.hp-=50; createParticle(200,300,50); } if(t==='O') { if(player.drones.length<2) player.drones.push({x:player.x, y:player.y}); else score+=1000; } }
        function checkColl(r1, r2) { return r1.x < r2.x + r2.w && r1.x + r1.w > r2.x && r1.y < r2.y + r2.h && r1.y + r1.h > r2.y; }
        
        function hitPlayer() {
            if(player.invincible > 0) return;
            if(player.shield) { player.shield = false; player.invincible = 60; playSound('shield'); }
            else {
                isRunning = false; saveScore(currentUsername, score); checkUnlock(); try { stopBgm(); playBgm('end'); } catch(e){}
                document.getElementById('final-score').innerText = "SCORE: " + score; document.getElementById('game-over-screen').style.display = 'flex';
            }
        }
        function checkUnlock() { let newUnlock = false; PLANES.forEach((p, i) => { if(!unlocked.includes(i) && score >= p.req) { unlocked.push(i); newUnlock = true; } }); if(newUnlock) { localStorage.setItem('pixelShooterUnlocks', JSON.stringify(unlocked)); document.getElementById('unlock-msg').innerText = "üéâ Ïã†Í∑ú Í∏∞Ï≤¥ Ìï¥Í∏à!"; } }

        let audioCtx, bgmOscs=[], bgmPlaying=false;
        const MELODIES = { intro: [{f:330,d:0.2}, {f:330,d:0.2}, {f:261,d:0.4}], game: [{f:440,d:0.1},{f:0,d:0.1},{f:523,d:0.1},{f:587,d:0.1}], end: [{f:523,d:0.2},{f:440,d:0.4}] };
        function initAudio() { try { if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)(); if(audioCtx.state === 'suspended') audioCtx.resume(); } catch(e){} }
        function playSound(t) { try { if(!audioCtx) return; const o=audioCtx.createOscillator(), g=audioCtx.createGain(); o.connect(g); g.connect(audioCtx.destination); const now=audioCtx.currentTime; if(t==='shoot'){ o.frequency.value=800; o.start(now); o.stop(now+0.1); } else { o.type='sawtooth'; o.frequency.value=100; o.start(now); o.stop(now+0.3); } g.gain.exponentialRampToValueAtTime(0.01, now+0.1); } catch(e){} }
        function playBgm(t) { try { if(!audioCtx) initAudio(); stopBgm(); const n=MELODIES[t]; let i=0; bgmPlaying=true; const l=()=>{ if(!bgmPlaying) return; const f=n[i].f; if(f){ const o=audioCtx.createOscillator(), g=audioCtx.createGain(); o.frequency.value=f; g.gain.value=0.05; o.connect(g); g.connect(audioCtx.destination); o.start(); o.stop(audioCtx.currentTime+n[i].d); bgmOscs.push(o); } setTimeout(l, n[i].d*1000); i=(i+1)%n.length; }; l(); } catch(e){} }
        function stopBgm() { bgmPlaying=false; bgmOscs.forEach(o=>{try{o.stop()}catch(e){}}); bgmOscs=[]; }
    </script>
</body>
</html>
